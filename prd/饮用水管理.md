# 3.2.1.1 概述

管理家庭饮用水的库存状态，记录饮水习惯，并预测下次换水时间。

> *”从“被动记录”升级为“主动预测”。不再依赖用户手动点击“喝完了”，而是以“换水 (Refill)”为核心锚点，利用时间衰减算法自动推演水位，并包含异常数据过滤机制。*
> 

# 3.2.1.2 用户交互

## **核心操作区：**

- `换新水 (Refill)`：**[主按钮]** 确认上一桶水已耗尽，新的一桶水已上架。这是系统学习用户习惯的关键动作。
- `手动校准 (Calibrate)`：**[辅助按钮]** 仅当预测水位与真实水位偏差过大时使用（例如：系统显示空了，实际还有一半）。
- `设置 (Config)`：设定最高水位 (`WaterMax`)，默认为 18.9L。

## **数据展示区：**

- **拟真液位图：** 实时显示剩余水量（L）和百分比。
- **续航预测：** 显示“约 XX 小时后见底”。
- **饮水趋势**：通过折线图展示仅七日的饮水总量，附带居民建议每日饮水量参考线。
- **首页管家提示：** 根据当前水量状态生成的短句（如“喝水进度不错！”）。

# 3.2.1.3 数据逻辑 (Data Logic)

**前置定义 (Pre-requisites):**

- `sleep_start`: 休眠开始时间 (用户设置，默认 23:00)。
- `sleep_end`: 休眠结束时间 (用户设置，默认 07:00)。
- `learned_hourly_consumption`: 长期习惯流速 (L/h)。
    - *初始默认值:* `(2.0L * family_member_count) / (24 - (sleep_end - sleep_start))`。
- `current_cycle_rate`: **[新增]** 本周期实时流速。默认为 `learned_hourly_consumption`，但会随用户校准而动态变化。

**输入参数 (Input):**

- `action`: `[REFILL, QUERY, CALIBRATE]`
- `timestamp`: 当前时间
- `water_max`: 容器容量
- `last_refill_timestamp`: 上次换水时间

---

### 1. 基础算法封装：计算有效活跃时长 (Helper Function)

> 核心逻辑： 计算两个时间点之间，扣除了睡觉时间的“真实喝水时长”。
> 
- **函数：** `get_active_duration(start_time, end_time)`
- **逻辑：**
    1. 计算总自然时长。
    2. 扣除落在 `sleep_start` 到 `sleep_end` 区间内的时长。
    - *例：* 从 20:00 到次日 08:00。自然时长 12h。睡眠 (23:00-07:00) 8h。有效活跃时长 = 4h。

---

### 2. 学习逻辑 (Learning Phase)

> 触发条件: action == REFILL核心: 结算本周期数据，更新长期习惯。
> 
1. **确定本周期最终流速 (`final_cycle_rate`):**
    - **场景 A (无校准):**
        - `active_hours` = `get_active_duration(last_refill_timestamp, timestamp)`
        - `final_cycle_rate` = `water_max` / `active_hours`
    - **场景 B (有校准 - 关键点):**
        - 直接读取当前的 `current_cycle_rate`。
        - *解释：因为用户曾在中途校准过，`current_cycle_rate` 已经被修正为最接近真实的流速，无需重新计算，直接采信该值。*
2. **异常值熔断 (Outlier Protection):**
    - 判定 `final_cycle_rate` 是否在有效区间内 (0.5 ~ 2.0 倍旧习惯)。
3. **更新长期模型 (加权进化):**
    - **IF 有效:**
        
        $$
        new\_learned\_rate = (old\_learned \times 0.7) + (final\_cycle\_rate \times 0.3)
        $$
        
    - *这里就是“旧习惯”被“用户校准后的新习惯”影响的具体时刻。*
    - **ELSE 无效:**
        - `new_learned_rate` = `old_learned` (保持不变)
4. **历史归档 (Trend Data Save):** <-- [新增步骤]
    - 将本周期的 `final_cycle_rate` 转换为每日等效消耗量 (e.g., Rate * 活动时间)，存入历史数据库，用于前端“饮水趋势”图表展示。
5. **状态重置:**
    - `current_level` = `water_max`
    - `current_cycle_rate` = `new_learned_rate` (下个周期重新从长期习惯出发)

---

### 3. 校准逻辑 (Calibration Phase)

> 触发条件: action == CALIBRATE场景: 系统以为剩 2L，用户输入真实值 input_value (比如 5L)。这证明用户喝得比系统预想的慢。
> 
1. **计算真实消耗量:**
    - `actual_consumed` = `water_max` - `input_value`
2. **计算真实活跃时长:**
    - `elapsed_active` = `get_active_duration(last_refill_timestamp, timestamp)`
3. **修正本周期流速 (Recalculate Rate):**
- **安全检查:** IF `elapsed_active` < 0.5 小时, 跳过流速修正 (防止分母过小导致数据漂移)，仅更新当前水位数值。
- `corrected_rate` = `actual_consumed` / `elapsed_active`
- **更新当前运行参数:** `current_cycle_rate` = `corrected_rate`
- *解释：既然用户提供了真值，说明在这个周期内，用户的喝水速度就是 `corrected_rate`。立即应用此速度，推演未来的走势将极其精准。*

---

### 4. 推演与预测逻辑 (Simulation & Prediction)

> 触发条件: action == QUERY (刷新界面)
> 

**A. 计算当前水位 (Current Level)**

1. `elapsed_active` = `get_active_duration(last_refill_timestamp, timestamp)`
2. `predicted_consumed` = `elapsed_active` * `current_cycle_rate`
    - *注：这里使用的是经过校准的 `current_cycle_rate`，而非死板的长期习惯。*
3. `current_level` = `water_max` - `predicted_consumed`

**B. 预测剩余时间 (Endurance Prediction) —— [生物钟处理]**

- **目标：** 算出从现在开始，还需要多少个**活跃小时**才会喝完。
- **步骤：**
    1. `active_hours_left` = `current_level` / `current_cycle_rate`
    2. **映射到自然时间:** 从 `timestamp` 开始向后推演，每经过 1 个自然小时：
        - 若在 **非睡眠时间**: `active_hours_left` 减 1。
        - 若在 **睡眠时间**: `active_hours_left` 不变（时间冻结）。
    3. 直到 `active_hours_left` <= 0，记录此时的时间点 `target_time`。
    4. 输出 `hours_remaining` = `target_time` - `timestamp`。
- **UI 效果案例:**
    - 现在是 22:00，还剩 2L 水 (够喝 2 个活跃小时)。
    - 22:00 - 23:00 (醒着): 消耗 1L。剩 1 小时量。
    - 23:00 - 07:00 (睡觉): **不消耗**。依然剩 1 小时量。
    - 07:00 - 08:00 (醒来): 消耗 1L。耗尽。
    - **结果显示:** "预计 10 小时后见底" (而不是 2 小时后)。

---

### 5. 提醒策略 (Notification Policy)

后端推送提醒时，增加一层判定：

- **IF** `current_time` 在 `sleep_window` 内：
    - **禁止发送** "水快空了" 的提醒。
    - 将提醒任务压入队列，延后至 `sleep_end` (e.g., 早上 7:00) 立即发送。

# 3.2.1.4 交互逻辑

本章节定义前端 App 如何响应用户操作，以及如何将后端返回的数据渲染为可视化组件。

## 1. 操作按钮逻辑 (Action Button Logic)

**A. [主按钮] 换新水 (Refill Button)**

- **触发行为:** 用户点击 -> 弹出二次确认框（防止误触）。
- **确认后动作:**
    1. **乐观更新 (Optimistic UI):** 立即在前端将水位动画推至 100%，并播放“注水”音效或触感反馈 (Haptic Feedback)。
    2. **API 请求:** 发送 `{ "action": "REFILL", "timestamp": NOW }`。
    3. **异常处理:** 若后端返回 `OUTLIER_IGNORED`（异常熔断），前端 Toast 弹窗提示：“很久没换水了，最近不在家吗？”“今天喝了很多水欸，家里来了客人吗？”并由用户进行确认，起到安慰剂作用，实际不影响后端将极端数据定义脏数据。

**B. [辅助按钮] 手动校准 (Calibrate Button)**

- **触发行为:** 用户点击 -> 弹出滑块或数字键盘。
- **交互约束:**
    - **最大值:** 不能超过 `WaterMax`。
    - **最小值:** 0。
    - **默认值:** 当前显示的预测水位（方便微调）。
- **确认后动作:**
    1. **API 请求:** 发送 `{ "action": "CALIBRATE", "input_value": USER_INPUT }`。
    2. **界面反馈:** 水位图平滑过渡到用户设定的高度。

**C. [设置] 最大水位 (WaterMax Config)**

- **触发行为:** 设置页 -> 输入框。
- **逻辑:** 修改本地存储的 `WaterMax` 常量，并同步至云端用户配置。修改后立即触发一次 `REFILL` 逻辑重置当前水位。

---

### 2. 数据展示逻辑 (Data Display Logic)

**A. 拟真液位图 (Water Level Visualizer)**

- **数据源:** `current_level` (后端计算值) / `water_max`。
- **渲染规则:**
    - **高度 (Height):** `(current_level / water_max) * 100%`。
    - **颜色映射 (Color Logic):**
        - `> 40%`: 深蓝 (Cyan/Blue)
        - `20% - 40%`: 蓝
        - `< 20%`: 红
    - **数值显示:** 保留 1 位小数 (e.g., "12.5 L")。

**B. 续航预测 (Endurance Prediction)**

- **数据源:** `predicted_hours` (后端返回)。
- **文案格式化:**
    - `> 24h`: 显示“约 X 天后见底” (Math.round(hours/24))。
    - `0h < X <= 24h`: 显示“约 X 小时后见底”。
    - `= 0h`: 显示“已耗尽，请换水”。

**C. 智能管家提示 (Smart Quote)-影响首页的管家**

- **逻辑:** 前端根据后端返回的状态码 (`status_code`) 映射本地文案库，避免频繁请求大段文本。
- **映射表 (Example):**
    - `NORMAL`: "当前消耗速度平稳。"
    - `FAST_CONSUMPTION`: "这两天喝水很勤快哦！" (流速 > 平均值 1.5 倍)
    - `SLOW_CONSUMPTION`: "记得多喝水，身体才健康。" (流速 < 平均值 0.5 倍)

**D. 饮水趋势图 (Trend Chart)**

- **数据源:** `history_7_days` (Array)。
- **渲染规则:**
    - **X 轴:** 过去 7 天的日期 (e.g., "Mon", "Tue")。
    - **Y 轴:** 每日消耗量 (L)。
    - **参考线 (Benchmark):** 在 Y=2.0 (或用户设定目标) 处绘制虚线。